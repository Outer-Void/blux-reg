#!/usr/bin/env python3
"""
blux-reg - Minimal local-first registry + audit CLI
Usage:
  blux-reg init
  blux-reg add-manifest PATH/TO/manifest.yaml
  blux-reg verify-line LINE-NUM
  blux-reg serve [port]
  blux-reg install PATH/TO/manifest.yaml
Notes:
 - Keys stored under ~/.config/blux-reg/keys/
 - Manifests under ~/blux-reg/manifests/
 - Audit log at ~/blux-reg/audit.log (append-only, JSONL)
"""
import argparse, os, sys, json, time, hashlib, base64, subprocess, tempfile, shutil

HOME = os.path.expanduser("~")
REGROOT = os.path.join(HOME, "blux-reg")
MANIFESTS = os.path.join(REGROOT, "manifests")
BIN = os.path.join(REGROOT, "bin")
AUDIT_LOG = os.path.join(REGROOT, "audit.log")
KEYDIR = os.path.join(HOME, ".config", "blux-reg", "keys")
PRIVATE_PEM = os.path.join(KEYDIR, "private.pem")
PUBLIC_PEM = os.path.join(KEYDIR, "public.pem")

def run(cmd, input_bytes=None):
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE if input_bytes is not None else None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out,err = p.communicate(input_bytes)
    return p.returncode, out, err

def ensure_dirs():
    os.makedirs(MANIFESTS, exist_ok=True)
    os.makedirs(BIN, exist_ok=True)
    os.makedirs(KEYDIR, exist_ok=True)

def init(args):
    ensure_dirs()
    if not os.path.exists(PRIVATE_PEM) or not os.path.exists(PUBLIC_PEM):
        print("[*] Generating RSA 3072 keypair (private.pem -> keep secret)")
        rc,out,err = run(["openssl","genpkey","-algorithm","RSA","-out",PRIVATE_PEM,"-pkeyopt","rsa_keygen_bits:3072"])
        if rc != 0:
            print("OpenSSL genpkey failed:", err.decode(), file=sys.stderr); sys.exit(1)
        rc,out,err = run(["openssl","rsa","-pubout","-in",PRIVATE_PEM,"-out",PUBLIC_PEM])
        if rc != 0:
            print("OpenSSL pubout failed:", err.decode(), file=sys.stderr); sys.exit(1)
        os.chmod(PRIVATE_PEM, 0o600)
        print("[+] Keys created:", PRIVATE_PEM, PUBLIC_PEM)
    else:
        print("[*] Keys already exist:", PRIVATE_PEM, PUBLIC_PEM)
    if not os.path.exists(AUDIT_LOG):
        open(AUDIT_LOG,"a").close()
        print("[*] Created empty audit.log:", AUDIT_LOG)
    print("[*] Registry root:", REGROOT)
    print("[*] Manifests:", MANIFESTS)
    print("[*] public key to publish:", PUBLIC_PEM)

def sha256_hex(data: bytes):
    return hashlib.sha256(data).hexdigest()

def make_envelope(payload_path):
    with open(payload_path,"rb") as f:
        payload = f.read()
    payload_sha = sha256_hex(payload)
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    prev_sha = None
    # compute prev line hash if exists
    try:
        with open(AUDIT_LOG,"rb") as f:
            last = None
            for line in f:
                if line.strip():
                    last = line
            if last:
                prev_sha = hashlib.sha256(last).hexdigest()
    except FileNotFoundError:
        prev_sha = None
    envelope = {
        "timestamp": timestamp,
        "payload_path": os.path.basename(payload_path),
        "payload_sha256": payload_sha,
        "prev_audit_sha256": prev_sha
    }
    return envelope, payload

def sign_envelope(envelope):
    env_json = json.dumps(envelope, separators=(",", ":"), sort_keys=True).encode()
    # sign with openssl dgst -sha256 -sign private.pem
    rc,out,err = run(["openssl","dgst","-sha256","-sign",PRIVATE_PEM], input_bytes=env_json)
    if rc != 0:
        print("OpenSSL sign failed:", err.decode(), file=sys.stderr); sys.exit(1)
    sig_b64 = base64.b64encode(out).decode()
    return env_json, sig_b64

def append_audit(envelope, signature):
    record = {"envelope": envelope, "signature": signature}
    with open(AUDIT_LOG,"ab") as f:
        f.write((json.dumps(record, separators=(",", ":"), sort_keys=True)+"\n").encode())
    print("[+] Appended audit line to", AUDIT_LOG)

def add_manifest(args):
    src = args.path
    if not os.path.exists(src):
        print("Manifest not found:", src); sys.exit(1)
    ensure_dirs()
    dst = os.path.join(MANIFESTS, os.path.basename(src))
    shutil.copy2(src, dst)
    print("[*] Copied manifest ->", dst)
    envelope, payload = make_envelope(dst)
    env_json, sig_b64 = sign_envelope(envelope)
    append_audit(envelope, sig_b64)
    print("[+] Manifest added and signed. Publish", PUBLIC_PEM, "with the manifest if you want others to verify.")

def verify_line(args):
    line_num = args.line
    if not os.path.exists(AUDIT_LOG):
        print("No audit log found."); sys.exit(1)
    with open(AUDIT_LOG,"rb") as f:
        lines = [l for l in f if l.strip()]
    if line_num < 1 or line_num > len(lines):
        print("Line number out of range. Found", len(lines), "lines"); sys.exit(1)
    entry = json.loads(lines[line_num-1])
    envelope = entry["envelope"]
    sig_b64 = entry["signature"]
    env_json = json.dumps(envelope, separators=(",", ":"), sort_keys=True).encode()
    sig = base64.b64decode(sig_b64)
    # write temp files
    with tempfile.NamedTemporaryFile(delete=False) as ef:
        ef.write(env_json)
        envf = ef.name
    with tempfile.NamedTemporaryFile(delete=False) as sf:
        sf.write(sig)
        sigf = sf.name
    try:
        rc,out,err = run(["openssl","dgst","-sha256","-verify",PUBLIC_PEM,"-signature",sigf,envf])
        ok = (rc == 0)
    finally:
        os.unlink(envf); os.unlink(sigf)
    print("VERIFY LINE", line_num, "->", "OK" if ok else "FAIL")
    if ok:
        print("envelope:", json.dumps(envelope, indent=2))
    else:
        print(err.decode())

def serve(args):
    port = args.port or 8080
    ensure_dirs()
    cwd = REGROOT
    print(f"[*] Serving {cwd} on port {port} (python -m http.server). Ctrl-C to stop.")
    os.execvp("python3", ["python3","-m","http.server",str(port)])

def install(args):
    src = args.path
    # Verify local signature matches manifest entry
    # Calculate sha of payload, find matching audit line with payload_path and payload_sha256 and valid signature
    if not os.path.exists(src):
        print("manifest not found:", src); sys.exit(1)
    with open(src,"rb") as f:
        payload = f.read()
    payload_sha = sha256_hex(payload)
    # search audit log for matching payload_path/payload_sha
    found = None
    if os.path.exists(AUDIT_LOG):
        with open(AUDIT_LOG,"r") as f:
            for i,line in enumerate(f, start=1):
                if not line.strip(): continue
                entry = json.loads(line)
                env = entry["envelope"]
                if env.get("payload_path")==os.path.basename(src) and env.get("payload_sha256")==payload_sha:
                    found = (i, entry)
                    break
    if not found:
        print("No signed audit entry found for this manifest. Aborting install."); sys.exit(1)
    # verify signature of that line
    line_index, entry = found
    # write envelope to temp and signature to temp then verify
    env_json = json.dumps(entry["envelope"], separators=(",", ":"), sort_keys=True).encode()
    sig = base64.b64decode(entry["signature"])
    with tempfile.NamedTemporaryFile(delete=False) as ef:
        ef.write(env_json); envf=ef.name
    with tempfile.NamedTemporaryFile(delete=False) as sf:
        sf.write(sig); sigf=sf.name
    try:
        rc,out,err = run(["openssl","dgst","-sha256","-verify",PUBLIC_PEM,"-signature",sigf,envf])
        ok = (rc==0)
    finally:
        os.unlink(envf); os.unlink(sigf)
    if not ok:
        print("Signature verification failed. Aborting."); sys.exit(1)
    # install: copy payload into ~/.local/blux/components/<name>/
    compdir = os.path.join(HOME,".local","blux","components",os.path.splitext(os.path.basename(src))[0])
    os.makedirs(compdir, exist_ok=True)
    shutil.copy2(src, os.path.join(compdir, os.path.basename(src)))
    print("[+] Installed manifest to", compdir)
    # optional: you could fetch actual entrypoints/artifacts if manifest references remote URL. Keep this minimal.

def main():
    ap = argparse.ArgumentParser()
    sub = ap.add_subparsers(dest="cmd")
    sub.add_parser("init")
    p = sub.add_parser("add-manifest")
    p.add_argument("path")
    q = sub.add_parser("verify-line")
    q.add_argument("line", type=int)
    r = sub.add_parser("serve")
    r.add_argument("port", nargs="?", type=int)
    s = sub.add_parser("install")
    s.add_argument("path")
    args = ap.parse_args()
    if args.cmd is None:
        ap.print_help(); sys.exit(1)
    if args.cmd=="init":
        init(args)
    elif args.cmd=="add-manifest":
        class A: pass
        a=A(); a.path=args.path
        add_manifest(a)
    elif args.cmd=="verify-line":
        class A: pass
        a=A(); a.line=args.line
        verify_line(a)
    elif args.cmd=="serve":
        serve(args)
    elif args.cmd=="install":
        class A: pass
        a=A(); a.path=args.path
        install(a)

if __name__=="__main__":
    main()
